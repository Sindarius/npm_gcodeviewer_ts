What about the rest of the file processing and slicers?
  ⎿  Read WASM_FileProcessor\test.html (305 lines)
  ⎿  Read WASM_FileProcessor\README.md (226 lines)
  ⎿  Read WASM_FileProcessor\src\processor.rs (304 lines)
  ⎿  Read WASM_FileProcessor\src\slicers\slicer_base.rs (220 lines)
  ⎿  Read WASM_FileProcessor\src\slicers\mod.rs (3 lines)

● I'll enhance the slicer implementations and add comprehensive file
  processing features to the Rust+WASM processor.

● Update(WASM_FileProcessor\src\slicers\slicer_base.rs)
  ⎿  Updated WASM_FileProcessor\src\slicers\slicer_base.rs with 171
     additions and 17 removals
        1    use crate::gcode_line::Color4;
        2
        3 +  /// Feature types that slicers can identify
        4 +  #[derive(Debug, Clone, PartialEq)]
        5 +  pub enum FeatureType {
        6 +      Perimeter,
        7 +      ExternalPerimeter,
        8 +      InternalPerimeter,
        9 +      Infill,
       10 +      SolidInfill,
       11 +      TopSolidInfill,
       12 +      Support,
       13 +      SupportInterface,
       14 +      BridgeInfill,
       15 +      GapFill,
       16 +      Skirt,
       17 +      Brim,
       18 +      WipeTower,
       19 +      Unknown,
       20 +  }
       21 +  
       22 +  /// Layer information
       23 +  #[derive(Debug, Clone)]
       24 +  pub struct LayerInfo {
       25 +      pub layer_number: u32,
       26 +      pub layer_height: f64,
       27 +      pub z_position: f64,
       28 +  }
       29 +  
       30    /// Base trait for slicer-specific behavior
       31    pub trait SlicerBase {
       32 -      fn get_feature_color(&self) -> Color4;
       33 -      fn is_perimeter(&self) -> bool;
       34 -      fn is_support(&self) -> bool;
       32 +      fn get_feature_color(&self, feature: &FeatureType
          +  ) -> Color4;
       33 +      fn parse_feature_from_comment(&self, comment: &str) ->       
          +  Option<FeatureType>;
       34 +      fn parse_layer_info(&self, comment: &str) -> 
          + Option<LayerInfo>;
       35 +      fn is_perimeter_comment(&self, comment: &str) -> bool;       
       36 +      fn is_support_comment(&self, comment: &str) -> bool;
       37 +      fn get_temperature_from_comment(&self, comment: &str)        
          + -> Option<f64>;
       38        fn detect_slicer(file_content: &str) -> bool where
            Self: Sized;
       39        fn get_name(&self) -> &str;
       40 +      fn get_version_info(&self, file_content: &str) -> 
          + Option<String>;
       41    }
       42
       43    /// Generic slicer implementation (fallback)
     ...
       23    }
       24
       25    impl SlicerBase for GenericSlicer {
       26 -      fn get_feature_color(&self) -> Color4 {
       27 -          Color4::white()
       26 +      fn get_feature_color(&self, feature: &FeatureType
          +  ) -> Color4 {
       27 +          match feature {
       28 +              FeatureType::Perimeter | 
          + FeatureType::ExternalPerimeter => Color4::new(1.0, 1.0, 
          + 1.0, 1.0),
       29 +              FeatureType::Infill => Color4::new(0.8, 0.8,         
          + 0.8, 1.0),
       30 +              FeatureType::Support => Color4::new(0.6, 0.6,        
          + 1.0, 1.0),
       31 +              _ => Color4::white(),
       32 +          }
       33        }
       34
       35 -      fn is_perimeter(&self) -> bool {
       36 -          false // Generic slicer doesn't differentiate
       35 +      fn parse_feature_from_comment(&self, _comment: &str)         
          + -> Option<FeatureType> {
       36 +          None // Generic slicer doesn't parse features
       37        }
       38
       39 -      fn is_support(&self) -> bool {
       40 -          false // Generic slicer doesn't differentiate
       39 +      fn parse_layer_info(&self, _comment: &str) -> 
          + Option<LayerInfo> {
       40 +          None // Generic parsing doesn't extract layer info       
       41        }
       42
       43 +      fn is_perimeter_comment(&self, _comment: &str) -> bool       
          +  {
       44 +          false
       45 +      }
       46 +      
       47 +      fn is_support_comment(&self, _comment: &str) -> bool {       
       48 +          false
       49 +      }
       50 +      
       51 +      fn get_temperature_from_comment(&self, _comment: &str)       
          +  -> Option<f64> {
       52 +          None
       53 +      }
       54 +      
       55        fn detect_slicer(file_content: &str) -> bool {
       56            // Generic slicer is always a fallback
       57            true
     ...
       43        fn get_name(&self) -> &str {
       44            &self.name
       45        }
       46 +      
       47 +      fn get_version_info(&self, _file_content: &str) -> 
          + Option<String> {
       48 +          None
       49 +      }
       50    }
       51
       52    /// Detect slicer type from file content
     ...
        92    }
        93
        94    impl SlicerBase for PrusaSlicer {
        95 -      fn get_feature_color(&self) -> Color4 {
        96 -          Color4::new(1.0, 0.8, 0.0, 1.0) // Orange-ish
        95 +      fn get_feature_color(&self, feature: &FeatureType
           +  ) -> Color4 {
        96 +          match feature {
        97 +              FeatureType::ExternalPerimeter => 
           + Color4::new(1.0, 0.4, 0.0, 1.0), // Orange
        98 +              FeatureType::Perimeter | 
           + FeatureType::InternalPerimeter => Color4::new(1.0, 0.8, 
           + 0.0, 1.0), // Yellow-orange
        99 +              FeatureType::Infill => Color4::new(0.0, 1.0,        
           + 0.0, 1.0), // Green
       100 +              FeatureType::SolidInfill | 
           + FeatureType::TopSolidInfill => Color4::new(0.0, 0.8, 0.0,        
           + 1.0), // Dark green
       101 +              FeatureType::Support => Color4::new(0.0, 0.4,       
           +  1.0, 1.0), // Blue
       102 +              FeatureType::SupportInterface => 
           + Color4::new(0.4, 0.8, 1.0, 1.0), // Light blue
       103 +              FeatureType::BridgeInfill => Color4::new(1.0,       
           +  0.0, 1.0, 1.0), // Magenta
       104 +              FeatureType::GapFill => Color4::new(0.8, 0.8,       
           +  0.0, 1.0), // Yellow
       105 +              FeatureType::Skirt | FeatureType::Brim => 
           + Color4::new(0.5, 0.5, 0.5, 1.0), // Gray
       106 +              _ => Color4::new(1.0, 1.0, 1.0, 1.0), // 
           + White for unknown
       107 +          }
       108        }
       109
       110 -      fn is_perimeter(&self) -> bool {
       111 -          // TODO: Implement PrusaSlicer-specific perimeter       
           -  detection
       112 -          false
       110 +      fn parse_feature_from_comment(&self, comment: &str)         
           + -> Option<FeatureType> {
       111 +          let comment_lower = comment.to_lowercase();
       112 +
       113 +          if comment_lower.contains("external perimeter") {       
       114 +              Some(FeatureType::ExternalPerimeter)
       115 +          } else if comment_lower.contains("perimeter") {
       116 +              Some(FeatureType::Perimeter)
       117 +          } else if comment_lower.contains("solid infill")        
           + {
       118 +              Some(FeatureType::SolidInfill)
       119 +          } else if comment_lower.contains("top solid 
           + infill") {
       120 +              Some(FeatureType::TopSolidInfill)
       121 +          } else if comment_lower.contains("infill") {
       122 +              Some(FeatureType::Infill)
       123 +          } else if comment_lower.contains("support 
           + interface") {
       124 +              Some(FeatureType::SupportInterface)
       125 +          } else if comment_lower.contains("support") {
       126 +              Some(FeatureType::Support)
       127 +          } else if comment_lower.contains("bridge") {
       128 +              Some(FeatureType::BridgeInfill)
       129 +          } else if comment_lower.contains("gap fill") {
       130 +              Some(FeatureType::GapFill)
       131 +          } else if comment_lower.contains("skirt") {
       132 +              Some(FeatureType::Skirt)
       133 +          } else if comment_lower.contains("brim") {
       134 +              Some(FeatureType::Brim)
       135 +          } else {
       136 +              None
       137 +          }
       138        }
       139
       140 -      fn is_support(&self) -> bool {
       141 -          // TODO: Implement PrusaSlicer-specific support         
           - detection
       142 -          false
       140 +      fn parse_layer_info(&self, comment: &str) -> 
           + Option<LayerInfo> {
       141 +          // PrusaSlicer format: "; LAYER_CHANGE\n; 
           + Z:0.3\n; layer num/total_layer_count: 1/245"
       142 +          if comment.contains("LAYER_CHANGE") || 
           + comment.starts_with("; Z:") {
       143 +              if let Some(z_start) = comment.find("; Z:") {       
       144 +                  let z_line = &comment[z_start + 4..];
       145 +                  if let Some(z_end) = 
           + z_line.find('\n').or_else(|| Some(z_line.len())) {
       146 +                      let z_str = z_line[..z_end].trim();
       147 +                      if let Ok(z_pos) = 
           + z_str.parse::<f64>() {
       148 +                          // Try to find layer number
       149 +                          let layer_num = if let 
           + Some(layer_start) = comment.find("layer 
           + num/total_layer_count: ") {
       150 +                              let layer_line = 
           + &comment[layer_start + 29..];
       151 +                              if let Some(slash_pos) = 
           + layer_line.find('/') {
       152 +
           + layer_line[..slash_pos].trim().parse::<u32>().unwrap_or(0)       
       153 +                              } else {
       154 +                                  0
       155 +                              }
       156 +                          } else {
       157 +                              0
       158 +                          };
       159 +
       160 +                          return Some(LayerInfo {
       161 +                              layer_number: layer_num,
       162 +                              layer_height: 0.2, // 
           + Default, could parse from settings
       163 +                              z_position: z_pos,
       164 +                          });
       165 +                      }
       166 +                  }
       167 +              }
       168 +          }
       169 +          None
       170        }
       171
       172 +      fn is_perimeter_comment(&self, comment: &str) -> bool       
           +  {
       173 +          let comment_lower = comment.to_lowercase();
       174 +          comment_lower.contains("perimeter")
       175 +      }
       176 +      
       177 +      fn is_support_comment(&self, comment: &str) -> bool {       
       178 +          let comment_lower = comment.to_lowercase();
       179 +          comment_lower.contains("support")
       180 +      }
       181 +      
       182 +      fn get_temperature_from_comment(&self, comment: &str)       
           +  -> Option<f64> {
       183 +          // Look for temperature settings in comments
       184 +          if comment.contains("temperature") {
       185 +              // Extract numeric value after "temperature"        
       186 +              if let Some(temp_start) = 
           + comment.find("temperature") {
       187 +                  let temp_substr = &comment[temp_start..];       
           +  
       188 +                  for word in 
           + temp_substr.split_whitespace() {
       189 +                      if let Ok(temp) = 
           + word.trim_matches(&[';', '°', 'C', '=', 
           + ':'][..]).parse::<f64>() {
       190 +                          if temp > 0.0 && temp < 500.0 {         
           + // Reasonable temperature range
       191 +                              return Some(temp);
       192 +                          }
       193 +                      }
       194 +                  }
       195 +              }
       196 +          }
       197 +          None
       198 +      }
       199 +      
       200        fn detect_slicer(file_content: &str) -> bool {
       201            file_content.contains("; generated by
             PrusaSlicer")
       202        }
     ...
       113        fn get_name(&self) -> &str {
       114            &self.name
       115        }
       116 +      
       117 +      fn get_version_info(&self, file_content: &str) -> 
           + Option<String> {
       118 +          // Extract PrusaSlicer version: "; generated by         
           + PrusaSlicer 2.6.0+win64 on 2023-04-15 at 14:30:25 UTC"
       119 +          if let Some(start) = file_content.find("; 
           + generated by PrusaSlicer ") {
       120 +              let version_line = &file_content[start + 
           + 27..];
       121 +              if let Some(end) = version_line.find(" on 
           + ").or_else(|| version_line.find('\n')) {
       122 +                  return 
           + Some(version_line[..end].trim().to_string());
       123 +              }
       124 +          }
       125 +          None
       126 +      }
       127    }
       128
       129    pub struct CuraSlicer {

● Update(WASM_FileProcessor\src\slicers\slicer_base.rs)
  ⎿  Updated WASM_FileProcessor\src\slicers\slicer_base.rs with 278
     additions and 22 removals
       282    }
       283
       284    impl SlicerBase for CuraSlicer {
       285 -      fn get_feature_color(&self) -> Color4 {
       286 -          Color4::new(0.0, 0.8, 1.0, 1.0) // Cyan-ish
       285 +      fn get_feature_color(&self, feature: &FeatureType
           +  ) -> Color4 {
       286 +          match feature {
       287 +              FeatureType::ExternalPerimeter => 
           + Color4::new(0.0, 0.6, 1.0, 1.0), // Cyan
       288 +              FeatureType::Perimeter | 
           + FeatureType::InternalPerimeter => Color4::new(0.0, 0.8, 
           + 1.0, 1.0), // Light cyan
       289 +              FeatureType::Infill => Color4::new(0.8, 0.4,        
           + 0.0, 1.0), // Orange
       290 +              FeatureType::SolidInfill | 
           + FeatureType::TopSolidInfill => Color4::new(1.0, 0.6, 0.0,        
           + 1.0), // Bright orange
       291 +              FeatureType::Support => Color4::new(1.0, 0.0,       
           +  0.8, 1.0), // Magenta
       292 +              FeatureType::SupportInterface => 
           + Color4::new(1.0, 0.4, 1.0, 1.0), // Light magenta
       293 +              FeatureType::Skirt | FeatureType::Brim => 
           + Color4::new(0.6, 0.6, 0.6, 1.0), // Gray
       294 +              _ => Color4::new(1.0, 1.0, 1.0, 1.0), // 
           + White
       295 +          }
       296        }
       297
       298 -      fn is_perimeter(&self) -> bool {
       299 -          // TODO: Implement Cura-specific perimeter 
           - detection
       300 -          false
       298 +      fn parse_feature_from_comment(&self, comment: &str)         
           + -> Option<FeatureType> {
       299 +          // Cura uses different comment formats: 
           + ";TYPE:WALL-OUTER", ";TYPE:FILL", etc.
       300 +          if comment.starts_with(";TYPE:") {
       301 +              let type_str = 
           + &comment[6..].trim().to_lowercase();
       302 +              match type_str {
       303 +                  "wall-outer" => 
           + Some(FeatureType::ExternalPerimeter),
       304 +                  "wall-inner" => 
           + Some(FeatureType::InternalPerimeter), 
       305 +                  "fill" => Some(FeatureType::Infill),
       306 +                  "skin" => Some(FeatureType::SolidInfill),       
       307 +                  "support" => Some(FeatureType::Support),        
       308 +                  "support-interface" => 
           + Some(FeatureType::SupportInterface),
       309 +                  "skirt" => Some(FeatureType::Skirt),
       310 +                  "prime-tower" => 
           + Some(FeatureType::WipeTower),
       311 +                  _ => None,
       312 +              }
       313 +          } else {
       314 +              None
       315 +          }
       316        }
       317
       318 -      fn is_support(&self) -> bool {
       319 -          // TODO: Implement Cura-specific support 
           - detection  
       320 -          false
       318 +      fn parse_layer_info(&self, comment: &str) -> 
           + Option<LayerInfo> {
       319 +          // Cura format: ";LAYER:0", ";LAYER_COUNT:245"
       320 +          if comment.starts_with(";LAYER:") {
       321 +              let layer_str = &comment[7..].trim();
       322 +              if let Ok(layer_num) = 
           + layer_str.parse::<u32>() {
       323 +                  return Some(LayerInfo {
       324 +                      layer_number: layer_num,
       325 +                      layer_height: 0.2, // Default, could        
           + be parsed from header
       326 +                      z_position: layer_num as f64 * 0.2,         
           + // Estimate
       327 +                  });
       328 +              }
       329 +          }
       330 +          None
       331        }
       332
       333 +      fn is_perimeter_comment(&self, comment: &str) -> bool       
           +  {
       334 +          comment.contains("WALL") || 
           + comment.contains("wall")
       335 +      }
       336 +      
       337 +      fn is_support_comment(&self, comment: &str) -> bool {       
       338 +          comment.contains("SUPPORT") || 
           + comment.contains("support")
       339 +      }
       340 +      
       341 +      fn get_temperature_from_comment(&self, comment: &str)       
           +  -> Option<f64> {
       342 +          // Look for Cura temperature comments
       343 +          if comment.contains("temperature") || 
           + comment.contains("M104") || comment.contains("M109") {
       344 +              for part in comment.split_whitespace() {
       345 +                  if part.starts_with('S') {
       346 +                      if let Ok(temp) = 
           + part[1..].parse::<f64>() {
       347 +                          if temp > 0.0 && temp < 500.0 {
       348 +                              return Some(temp);
       349 +                          }
       350 +                      }
       351 +                  }
       352 +              }
       353 +          }
       354 +          None
       355 +      }
       356 +      
       357        fn detect_slicer(file_content: &str) -> bool {
       358 -          file_content.contains(";Generated with 
           -  Cura_SteamEngine")
       358 +          file_content.contains(";Generated with 
           +  Cura_SteamEngine") || 
       359 +          file_content.contains(";FLAVOR:")
       360        }
       361
       362        fn get_name(&self) -> &str {
       363            &self.name
       364        }
       365 +      
       366 +      fn get_version_info(&self, file_content: &str) -> 
           + Option<String> {
       367 +          // Extract Cura version from comment lines
       368 +          for line in file_content.lines().take(50) {
       369 +              if line.contains("Cura_SteamEngine") {
       370 +                  if let Some(start) = 
           + line.find("Cura_SteamEngine ") {
       371 +                      let version_part = &line[start + 
           + 17..];
       372 +                      if let Some(end) = 
           + version_part.find(' ').or_else(|| 
           + Some(version_part.len())) {
       373 +                          return 
           + Some(version_part[..end].trim().to_string());
       374 +                      }
       375 +                  }
       376 +              }
       377 +          }
       378 +          None
       379 +      }
       380    }
       381
       382    pub struct SuperSlicer {
     ...
       318    }
       319
       320    impl SlicerBase for SuperSlicer {
       321 -      fn get_feature_color(&self) -> Color4 {
       322 -          Color4::new(0.8, 1.0, 0.0, 1.0) // Green-ish
       321 +      fn get_feature_color(&self, feature: &FeatureType
           +  ) -> Color4 {
       322 +          match feature {
       323 +              FeatureType::ExternalPerimeter => 
           + Color4::new(0.6, 1.0, 0.0, 1.0), // Lime green
       324 +              FeatureType::Perimeter | 
           + FeatureType::InternalPerimeter => Color4::new(0.8, 1.0, 
           + 0.0, 1.0), // Yellow-green
       325 +              FeatureType::Infill => Color4::new(0.0, 0.8,        
           + 0.4, 1.0), // Green
       326 +              FeatureType::SolidInfill | 
           + FeatureType::TopSolidInfill => Color4::new(0.0, 1.0, 0.6,        
           + 1.0), // Bright green
       327 +              FeatureType::Support => Color4::new(0.4, 0.4,       
           +  1.0, 1.0), // Blue
       328 +              FeatureType::SupportInterface => 
           + Color4::new(0.6, 0.6, 1.0, 1.0), // Light blue
       329 +              FeatureType::BridgeInfill => Color4::new(1.0,       
           +  0.8, 0.0, 1.0), // Gold
       330 +              FeatureType::GapFill => Color4::new(1.0, 1.0,       
           +  0.4, 1.0), // Light yellow
       331 +              _ => Color4::new(1.0, 1.0, 1.0, 1.0), // 
           + White
       332 +          }
       333        }
       334
       335 -      fn is_perimeter(&self) -> bool {
       336 -          false
       335 +      fn parse_feature_from_comment(&self, comment: &str)         
           + -> Option<FeatureType> {
       336 +          // SuperSlicer uses PrusaSlicer-like comments
       337 +          let comment_lower = comment.to_lowercase();
       338 +
       339 +          if comment_lower.contains("external perimeter") {       
       340 +              Some(FeatureType::ExternalPerimeter)
       341 +          } else if comment_lower.contains("perimeter") {
       342 +              Some(FeatureType::Perimeter)
       343 +          } else if comment_lower.contains("solid infill")        
           + {
       344 +              Some(FeatureType::SolidInfill)
       345 +          } else if comment_lower.contains("top solid 
           + infill") {
       346 +              Some(FeatureType::TopSolidInfill)
       347 +          } else if comment_lower.contains("infill") {
       348 +              Some(FeatureType::Infill)
       349 +          } else if comment_lower.contains("support 
           + interface") {
       350 +              Some(FeatureType::SupportInterface)
       351 +          } else if comment_lower.contains("support") {
       352 +              Some(FeatureType::Support)
       353 +          } else if comment_lower.contains("bridge") {
       354 +              Some(FeatureType::BridgeInfill)
       355 +          } else if comment_lower.contains("gap fill") {
       356 +              Some(FeatureType::GapFill)
       357 +          } else {
       358 +              None
       359 +          }
       360        }
       361
       362 -      fn is_support(&self) -> bool {
       363 -          false
       362 +      fn parse_layer_info(&self, comment: &str) -> 
           + Option<LayerInfo> {
       363 +          // SuperSlicer uses similar format to PrusaSlicer       
       364 +          if comment.contains("LAYER_CHANGE") || 
           + comment.starts_with("; Z:") {
       365 +              if let Some(z_start) = comment.find("; Z:") {       
       366 +                  let z_line = &comment[z_start + 4..];
       367 +                  if let Some(z_end) = 
           + z_line.find('\n').or_else(|| Some(z_line.len())) {
       368 +                      let z_str = z_line[..z_end].trim();
       369 +                      if let Ok(z_pos) = 
           + z_str.parse::<f64>() {
       370 +                          return Some(LayerInfo {
       371 +                              layer_number: 0, // Could be        
           + extracted if available
       372 +                              layer_height: 0.2,
       373 +                              z_position: z_pos,
       374 +                          });
       375 +                      }
       376 +                  }
       377 +              }
       378 +          }
       379 +          None
       380        }
       381
       382 +      fn is_perimeter_comment(&self, comment: &str) -> bool       
           +  {
       383 +          comment.to_lowercase().contains("perimeter")
       384 +      }
       385 +      
       386 +      fn is_support_comment(&self, comment: &str) -> bool {       
       387 +          comment.to_lowercase().contains("support")
       388 +      }
       389 +      
       390 +      fn get_temperature_from_comment(&self, comment: &str)       
           +  -> Option<f64> {
       391 +          // Similar to PrusaSlicer temperature parsing
       392 +          if comment.contains("temperature") {
       393 +              if let Some(temp_start) = 
           + comment.find("temperature") {
       394 +                  let temp_substr = &comment[temp_start..];       
           +  
       395 +                  for word in 
           + temp_substr.split_whitespace() {
       396 +                      if let Ok(temp) = 
           + word.trim_matches(&[';', '°', 'C', '=', 
           + ':'][..]).parse::<f64>() {
       397 +                          if temp > 0.0 && temp < 500.0 {
       398 +                              return Some(temp);
       399 +                          }
       400 +                      }
       401 +                  }
       402 +              }
       403 +          }
       404 +          None
       405 +      }
       406 +      
       407        fn detect_slicer(file_content: &str) -> bool {
       408            file_content.contains("; generated by
             SuperSlicer")
       409        }
     ...
       337        fn get_name(&self) -> &str {
       338            &self.name
       339        }
       340 +      
       341 +      fn get_version_info(&self, file_content: &str) -> 
           + Option<String> {
       342 +          if let Some(start) = file_content.find("; 
           + generated by SuperSlicer ") {
       343 +              let version_line = &file_content[start + 
           + 28..];
       344 +              if let Some(end) = version_line.find(" on 
           + ").or_else(|| version_line.find('\n')) {
       345 +                  return 
           + Some(version_line[..end].trim().to_string());
       346 +              }
       347 +          }
       348 +          None
       349 +      }
       350    }
       351
       352    pub struct OrcaSlicer {
     ...
       352    }
       353
       354    impl SlicerBase for OrcaSlicer {
       355 -      fn get_feature_color(&self) -> Color4 {
       356 -          Color4::new(1.0, 0.0, 0.8, 1.0) // Magenta-ish
       355 +      fn get_feature_color(&self, feature: &FeatureType
           +  ) -> Color4 {
       356 +          match feature {
       357 +              FeatureType::ExternalPerimeter => 
           + Color4::new(1.0, 0.0, 0.6, 1.0), // Deep magenta
       358 +              FeatureType::Perimeter | 
           + FeatureType::InternalPerimeter => Color4::new(1.0, 0.0, 
           + 0.8, 1.0), // Magenta
       359 +              FeatureType::Infill => Color4::new(0.8, 0.0,        
           + 1.0, 1.0), // Purple
       360 +              FeatureType::SolidInfill | 
           + FeatureType::TopSolidInfill => Color4::new(0.6, 0.0, 1.0,        
           + 1.0), // Blue-purple
       361 +              FeatureType::Support => Color4::new(1.0, 0.4,       
           +  0.0, 1.0), // Orange
       362 +              FeatureType::SupportInterface => 
           + Color4::new(1.0, 0.6, 0.4, 1.0), // Light orange
       363 +              FeatureType::BridgeInfill => Color4::new(0.0,       
           +  1.0, 1.0, 1.0), // Cyan
       364 +              FeatureType::GapFill => Color4::new(1.0, 1.0,       
           +  0.0, 1.0), // Yellow
       365 +              _ => Color4::new(1.0, 1.0, 1.0, 1.0), // 
           + White
       366 +          }
       367        }
       368
       369 -      fn is_perimeter(&self) -> bool {
       370 -          false
       369 +      fn parse_feature_from_comment(&self, comment: &str)         
           + -> Option<FeatureType> {
       370 +          // OrcaSlicer uses enhanced PrusaSlicer-like 
           + comments
       371 +          let comment_lower = comment.to_lowercase();
       372 +
       373 +          if comment_lower.contains("outer wall") || 
           + comment_lower.contains("external perimeter") {
       374 +              Some(FeatureType::ExternalPerimeter)
       375 +          } else if comment_lower.contains("inner wall") ||       
           +  comment_lower.contains("perimeter") {
       376 +              Some(FeatureType::InternalPerimeter)
       377 +          } else if comment_lower.contains("top surface")         
           + || comment_lower.contains("top solid infill") {
       378 +              Some(FeatureType::TopSolidInfill)
       379 +          } else if comment_lower.contains("bottom 
           + surface") || comment_lower.contains("solid infill") {
       380 +              Some(FeatureType::SolidInfill)
       381 +          } else if comment_lower.contains("infill") {
       382 +              Some(FeatureType::Infill)
       383 +          } else if comment_lower.contains("support 
           + interface") {
       384 +              Some(FeatureType::SupportInterface)
       385 +          } else if comment_lower.contains("support") {
       386 +              Some(FeatureType::Support)
       387 +          } else if comment_lower.contains("bridge") {
       388 +              Some(FeatureType::BridgeInfill)
       389 +          } else if comment_lower.contains("gap fill") {
       390 +              Some(FeatureType::GapFill)
       391 +          } else {
       392 +              None
       393 +          }
       394        }
       395
       396 -      fn is_support(&self) -> bool {
       397 -          false
       396 +      fn parse_layer_info(&self, comment: &str) -> 
           + Option<LayerInfo> {
       397 +          // OrcaSlicer has enhanced layer info
       398 +          if comment.contains("LAYER_CHANGE") || 
           + comment.starts_with("; Z:") {
       399 +              if let Some(z_start) = comment.find("; Z:") {       
       400 +                  let z_line = &comment[z_start + 4..];
       401 +                  if let Some(z_end) = 
           + z_line.find('\n').or_else(|| Some(z_line.len())) {
       402 +                      let z_str = z_line[..z_end].trim();
       403 +                      if let Ok(z_pos) = 
           + z_str.parse::<f64>() {
       404 +                          // Look for layer number in 
           + OrcaSlicer format
       405 +                          let layer_num = if 
           + comment.contains("LAYER:") {
       406 +                              if let Some(layer_start) = 
           + comment.find("LAYER:") {
       407 +                                  let layer_line = 
           + &comment[layer_start + 6..];
       408 +                                  if let Some(layer_end) =        
           + layer_line.find(&['\n', ' ', ';'][..]) {
       409 +
           + layer_line[..layer_end].trim().parse::<u32>().unwrap_or(0)       
       410 +                                  } else {
       411 +                                      0
       412 +                                  }
       413 +                              } else {
       414 +                                  0
       415 +                              }
       416 +                          } else {
       417 +                              0
       418 +                          };
       419 +
       420 +                          return Some(LayerInfo {
       421 +                              layer_number: layer_num,
       422 +                              layer_height: 0.2,
       423 +                              z_position: z_pos,
       424 +                          });
       425 +                      }
       426 +                  }
       427 +              }
       428 +          }
       429 +          None
       430        }
       431
       432 +      fn is_perimeter_comment(&self, comment: &str) -> bool       
           +  {
       433 +          let comment_lower = comment.to_lowercase();
       434 +          comment_lower.contains("wall") || 
           + comment_lower.contains("perimeter")
       435 +      }
       436 +      
       437 +      fn is_support_comment(&self, comment: &str) -> bool {       
       438 +          comment.to_lowercase().contains("support")
       439 +      }
       440 +      
       441 +      fn get_temperature_from_comment(&self, comment: &str)       
           +  -> Option<f64> {
       442 +          if comment.contains("temperature") || 
           + comment.contains("nozzle_temperature") {
       443 +              for word in comment.split_whitespace() {
       444 +                  if let Ok(temp) = 
           + word.trim_matches(&[';', '°', 'C', '=', 
           + ':'][..]).parse::<f64>() {
       445 +                      if temp > 0.0 && temp < 500.0 {
       446 +                          return Some(temp);
       447 +                      }
       448 +                  }
       449 +              }
       450 +          }
       451 +          None
       452 +      }
       453 +      
       454        fn detect_slicer(file_content: &str) -> bool {
       455 -          file_content.contains("generated by OrcaSlicer")        
       455 +          file_content.contains("generated by OrcaSlicer")        
           +   ||
       456 +          file_content.contains("; OrcaSlicer")
       457        }
       458
       459        fn get_name(&self) -> &str {
       460            &self.name
       461        }
       462 +      
       463 +      fn get_version_info(&self, file_content: &str) -> 
           + Option<String> {
       464 +          if let Some(start) = file_content.find("generated       
           +  by OrcaSlicer ") {
       465 +              let version_line = &file_content[start + 
           + 24..];
       466 +              if let Some(end) = version_line.find(' 
           + ').or_else(|| version_line.find('\n')) {
       467 +                  return 
           + Some(version_line[..end].trim().to_string());
       468 +              }
       469 +          }
       470 +          None
       471 +      }
       472    }
       473   \ No newline at end of file

● Now I'll add the remaining G-code command parsers including G2/G3 arcs,     
  tool changes, and temperature commands:

● Write(WASM_FileProcessor\src\parsers\g2_g3.rs)
  ⎿  Wrote 1 lines to WASM_FileProcessor\src\parsers\g2_g3.rs
     use crate::gcode_line::{GCodeLine, ArcMove, Vector3};
     use crate::processor_properties::ProcessorProperties;
     use crate::utils::{parse_number_fast, skip_whitespace};
     /// Parse G2 (clockwise arc) and G3 (counter-clockwise arc) commands     
     /// Format: G2/G3 Xnnn Ynnn Znnn Innn Jnnn Knnn Ennn Fnnn
     /// I, J, K are the arc center offsets from start position
     /// R can be used instead of I,J for radius (not implemented yet)        
     pub fn parse_arc_move(
         properties: &mut ProcessorProperties,

● Write(WASM_FileProcessor\src\parsers\tool_commands.rs)
  ⎿  Wrote 1 lines to WASM_FileProcessor\src\parsers\tool_commands.rs
     use crate::gcode_line::{GCodeLine, ToolCommand};
     use crate::processor_properties::ProcessorProperties;
     use crate::utils::{parse_number_fast, skip_whitespace};
     /// Parse tool change commands (T0, T1, etc.) and related M-codes        
     pub fn parse_tool_command(
         properties: &mut ProcessorProperties,
         line: &str,
         file_position: u32,
         line_number: u32,

● Update(WASM_FileProcessor\src\parsers\mod.rs)
  ⎿  Error editing file

● Read(WASM_FileProcessor\src\parsers\mod.rs)
  ⎿  Read 5 lines (ctrl+r to expand)

● Update(WASM_FileProcessor\src\parsers\mod.rs)
  ⎿  Updated WASM_FileProcessor\src\parsers\mod.rs with 5 additions and 1     
     removal
        1    pub mod process_line;
        2    pub mod g0_g1;
        3 +  pub mod g2_g3;
        4 +  pub mod tool_commands;
        5
        6    pub use process_line::*;
        7 -  pub use g0_g1::*;
        7   \ No newline at end of file
        8 +  pub use g0_g1::*;
        9 +  pub use g2_g3::*;
       10 +  pub use tool_commands::*;
       11   \ No newline at end of file

● Now I'll update the main process_line.rs to include the new parsers:        

● Read(WASM_FileProcessor\src\parsers\process_line.rs)
  ⎿  Read 299 lines (ctrl+r to expand)

● Update(WASM_FileProcessor\src\parsers\process_line.rs)
  ⎿  Updated WASM_FileProcessor\src\parsers\process_line.rs with 21
     additions and 7 removals
       2    use crate::processor_properties::ProcessorProperties;
       3    use crate::utils::{is_comment_line, detect_gcode_command,
           parse_parameter};
       4    use crate::parsers::g0_g1::{parse_g0_g1_move,
           is_g0_g1_command};
       5 +  use crate::parsers::g2_g3::parse_arc_move;
       6 +  use crate::parsers::tool_commands::{parse_tool_command, 
         + parse_m_command};
       7
       8    /// Main line processing function - routes lines to
           appropriate specialized parsers
       9    /// This is the entry point for processing each G-code line       
     ...
       55                    return Ok(create_command(file_position,
            line_number, line, command_upper));
       56                }
       57
       58 -              // G2/G3 Arc moves
          -   - TODO: Implement arc parsing
       59 -              "G2" | "G02" | "G3" | "G03" => {
       60 -                  // For now, treat as regular command
       61 -                  return Ok(create_command(file_position, 
          - line_number, line, command_upper));
       58 +              // G2/G3 Arc moves
       59 +              "G2" | "G02" => {
       60 +                  return parse_arc_move(props, line, true,         
          + file_position, line_number);
       61                }
       62 +              "G3" | "G03" => {
       63 +                  return parse_arc_move(props, line, false,        
          + file_position, line_number);
       64 +              }
       65
       66                // G28 Home
       67                "G28" => {
       68                    return Ok(create_command(file_position,
            line_number, line, command_upper));
       69                }
       70
       71 -              // M-codes
       71 +              // M-codes - route to specialized parser for         
          + temperature/tool commands
       72                _ if command_upper.starts_with('M') => {
       73 -                  return parse_mcode(props, line, 
          - file_position, line_number, &command_upper);
       73 +                  let mcode_num = 
          + command_upper[1..].parse::<u32>().unwrap_or(0);
       74 +                  match mcode_num {
       75 +                      // Temperature and tool-related 
          + M-codes
       76 +                      104 | 109 | 140 | 190 | 106 | 107 => {       
       77 +                          return parse_tool_command(props,         
          + line, file_position, line_number);
       78 +                      }
       79 +                      // Other M-codes
       80 +                      _ => {
       81 +                          return parse_m_command(props, 
          + line, file_position, line_number);
       82 +                      }
       83 +                  }
       84                }
       85
       86                // T-codes (tool changes)
       87                _ if command_upper.starts_with('T') => {
       88 -                  return parse_tool_change
          -  (props, line, file_position, line_number, &command_upper);       
       88 +                  return parse_tool_command
          +  (props, line, file_position, line_number);
       89                }
       90
       91                // Other G-codes

● I need to update the processor_properties.rs file to include the new        
  properties needed for tool and temperature tracking:

● Read(WASM_FileProcessor\src\processor_properties.rs)
  ⎿  Read 303 lines (ctrl+r to expand)

● Update(WASM_FileProcessor\src\processor_properties.rs)
  ⎿  Error editing file

● I need to add the missing properties to the ProcessorProperties struct.     
  Let me find the right location:

● Update(WASM_FileProcessor\src\processor_properties.rs)
  ⎿  Updated WASM_FileProcessor\src\processor_properties.rs with 18
     additions
        95        pub max_feed_rate: f64,
        96        pub min_feed_rate: f64,
        97
        98 +      // Extrusion tracking
        99 +      pub current_e: f64,
       100 +      pub total_extrusion: f64,
       101 +      pub absolute_extrusion: bool,
       102 +      
       103 +      // Temperature tracking
       104 +      pub target_hotend_temp: f64,
       105 +      pub target_bed_temp: f64,
       106 +      pub current_hotend_temp: f64,
       107 +      pub current_bed_temp: f64,
       108 +      
       109 +      // Stepper and hardware state
       110 +      pub steppers_enabled: bool,
       111 +      pub steps_per_mm_x: f64,
       112 +      pub steps_per_mm_y: f64,
       113 +      pub steps_per_mm_z: f64,
       114 +      pub steps_per_mm_e: f64,
       115 +      
       116        // Visual settings
       117        pub progress_color: Color4,
       118        pub progress_animation: bool,

● Update(WASM_FileProcessor\src\processor_properties.rs)
  ⎿  Updated WASM_FileProcessor\src\processor_properties.rs with 18
     additions
       170                current_feed_rate: 1500.0,
       171                max_feed_rate: 1.0,
       172                min_feed_rate: 999999999.0,
       173 +              current_e: 0.0,
       174 +              total_extrusion: 0.0,
       175 +              absolute_extrusion: true,
       176 +              target_hotend_temp: 0.0,
       177 +              target_bed_temp: 0.0,
       178 +              current_hotend_temp: 0.0,
       179 +              current_bed_temp: 0.0,
       180 +              steppers_enabled: true,
       181 +              steps_per_mm_x: 80.0,
       182 +              steps_per_mm_y: 80.0,
       183 +              steps_per_mm_z: 400.0,
       184 +              steps_per_mm_e: 420.0,
       185                progress_color: Color4::new(0.0, 1.0, 0.0,
             1.0),
       186                progress_animation: true,
       187                has_mixing: false,
     ...
       270            self.last_gcode_byte = 0;
       271            self.layer_dictionary.clear();
       272            self.current_position = Vector3::zero();
       273 +          self.current_e = 0.0;
       274 +          self.total_extrusion = 0.0;
       275            self.previous_z = 0.0;
       276            self.total_rendered_segments = 0;
       277            self.max_height = 0.0;
     ...
       277            self.max_feed_rate = 1.0;
       278            self.min_feed_rate = 999999999.0;
       279            self.current_z = 0.0;
       280 +          self.target_hotend_temp = 0.0;
       281 +          self.target_bed_temp = 0.0;
       282 +          self.current_hotend_temp = 0.0;
       283 +          self.current_bed_temp = 0.0;
       284
       285            // Reset tool to default
       286            if !self.tools.is_empty() {
  ⎿  5-hour limit reached ∙ resets 10am
     /upgrade to increase your usage limit.

╭────────────────────────────────────────────────────────────────────────────╮
│ >                                                                          │
╰────────────────────────────────────────────────────────────────────────────╯
  ⏵⏵ bypass permissions on (shift+tab to cycle)                            ◯  




