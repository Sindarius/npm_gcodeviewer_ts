import GenericBase from './genericbase'
import PrusaSlicer from './prusaslicer'
import Cura from './cura'
import SuperSlicer from './superslicer'
import OrcaSlicer from './orcaslicer'
import ideaMaker from './ideamaker'
import KiriMoto from './kirimoto'

// Cache for slicer detection patterns
const SLICER_PATTERNS = [
   { pattern: '; generated by PrusaSlicer', slicer: () => new PrusaSlicer() },
   { pattern: ';Generated with Cura_SteamEngine', slicer: () => new Cura() },
   { pattern: '; generated by SuperSlicer', slicer: () => new SuperSlicer() },
   { pattern: 'Sliced by ideaMaker', slicer: () => new ideaMaker() },
   { pattern: '; Generated by Kiri:Moto', slicer: () => new KiriMoto() },
   { pattern: 'generated by OrcaSlicer ', slicer: () => new OrcaSlicer() }
]

// Simple cache for recently detected slicers
const slicerCache = new Map<string, any>()
const CACHE_SIZE_LIMIT = 100

function getCacheKey(header: string): string {
   // Create a short hash of the first few lines for caching
   let hash = 0
   for (let i = 0; i < Math.min(header.length, 1000); i++) {
      const char = header.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to 32-bit integer
   }
   return hash.toString(36)
}

export function slicerFactory(gcode) {
   if (gcode == null) return null

   const header = gcode.substring(0, 10000)
   const cacheKey = getCacheKey(header)
   
   // Check cache first
   if (slicerCache.has(cacheKey)) {
      const SlicerClass = slicerCache.get(cacheKey)
      return new SlicerClass()
   }

   // Find matching slicer pattern
   for (const { pattern, slicer } of SLICER_PATTERNS) {
      if (header.includes(pattern)) {
         const slicerInstance = slicer()
         
         // Cache the slicer constructor for future use
         if (slicerCache.size >= CACHE_SIZE_LIMIT) {
            // Remove oldest entry if cache is full
            const firstKey = slicerCache.keys().next().value
            slicerCache.delete(firstKey)
         }
         slicerCache.set(cacheKey, slicerInstance.constructor)
         
         return slicerInstance
      }
   }

   // Default to generic base
   const genericSlicer = new GenericBase()
   slicerCache.set(cacheKey, GenericBase)
   return genericSlicer
}
